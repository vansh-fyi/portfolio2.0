<story-context id=".bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>3</epicId>
    <storyId>3.3</storyId>
    <title>Email API Integration</title>
    <status>drafted</status>
    <generatedAt>2025-11-20</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/sprint-artifacts/3-3-email-api-integration.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>developer</asA>
    <iWant>connect the lead-gen chat component to the backend email service</iWant>
    <soThat>the collected information can be sent to Vansh</soThat>
    <tasks>
      - Task 1: Implement tRPC client call to email.sendLead endpoint (AC: #1, #2)
        - Import tRPC client in lead-gen chat component
        - Create sendEmail function that calls trpc.email.sendLead.mutate()
        - Pass collected user data (name, email, message) to the endpoint
        - Integrate with conversational flow trigger (when user confirms details)

      - Task 2: Implement success and error handling UI (AC: #3, #4, #6)
        - Add confirmation message to chat on successful email send
        - Craft Ursa-personality confirmation message (conversational, authentic)
        - Add error message handling with fallback contact info
        - Craft Ursa-personality error messages (empathetic, helpful)
        - Test error scenarios (network failure, API timeout, invalid data)

      - Task 3: Add loading state indicator (AC: #5)
        - Implement loading state boolean in component
        - Display loading spinner or typing indicator while email is sending
        - Disable input during email transmission
        - Ensure loading state clears after success or error

      - Task 4: Integration testing (AC: #1-6)
        - Test complete flow: user confirms → API call → success message
        - Test error scenarios and verify error messages display correctly
        - Verify data formatting matches backend API contract (SendLeadInput)
        - Test loading state transitions (idle → loading → success/error)
        - Verify personality consistency in all message variants
    </tasks>
  </story>

  <acceptanceCriteria>
    1. Email Endpoint Integration: The lead-gen chat component successfully calls the backend email API endpoint (trpc.email.sendLead) when user confirms their details.

    2. Data Transmission: All collected information (name, email, message) is properly formatted and sent to the email API.

    3. Success Confirmation: A confirmation message is displayed in the chat interface when the email is successfully sent (e.g., "Thank you! Your message has been sent. Vansh will get back to you soon.").

    4. Error Handling: Appropriate error messages are shown if the email fails to send, with user-friendly guidance (e.g., "Oops! Something went wrong. Please try again or email directly at vansh@example.com").

    5. Loading State: The chat displays a loading indicator while the email is being sent to provide user feedback.

    6. Personality Consistency: All confirmation and error messages follow Ursa's conversational personality (tone, voice, vocabulary).
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR15 - Lead Generation Agent Email</section>
        <snippet>After collecting the information, the agent must send an email containing the details to Vansh's specified email address. The lead generation agent must not use the RAG system and should follow a more structured conversational flow.</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>FR21 - Backend Email Endpoint</section>
        <snippet>The backend service must provide an endpoint for the lead generation agent to send email.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>Email API Contract</section>
        <snippet>Procedure: trpc.email.sendLead. Input: SendLeadInput {name: string, email: string, message: string}. Output: SendLeadOutput {success: boolean, message?: string}. The backend uses Resend Node.js SDK for email delivery.</snippet>
      </doc>
      <doc>
        <path>docs/architecture.md</path>
        <title>Architecture Document</title>
        <section>API Communication Pattern</section>
        <snippet>Frontend to Backend: Communication handled via tRPC, ensuring type-safe API calls between React frontend and Mastra.AI backend. Error handling follows tRPC conventions with try-catch blocks.</snippet>
      </doc>
      <doc>
        <path>docs/epics.md</path>
        <title>Epic Breakdown</title>
        <section>Epic 3 - Story 3.3: Email API Integration</section>
        <snippet>As a developer, I want to connect the lead-gen chat component to the backend email service, so that the collected information can be sent to Vansh. Prerequisites: Story 3.1 (UI), Story 3.2 (Conversational Flow), Epic 4 Story 4.5 (Backend Email Endpoint).</snippet>
      </doc>
      <doc>
        <path>docs/PRD.md</path>
        <title>Product Requirements Document</title>
        <section>Ursa Personality - UX Principles</section>
        <snippet>Tone: Conversational, authentic, and passionate. Voice: Strongly first-person. Vocabulary: Clear, direct with informal touches (e.g., "coz"). Strategic use of emoji to convey emotion (avoiding overuse). Error messages should be empathetic and helpful.</snippet>
      </doc>
    </docs>

    <code>
      <file>
        <path>portfolio-react-template/src/components/LeadGenChat.tsx</path>
        <kind>component</kind>
        <symbol>LeadGenChat</symbol>
        <lines>1-385</lines>
        <reason>Lead-gen chat component that collects user data (name, email, projectDetails). Currently has conversation flow logic and CollectedData state. Needs email API integration in COMPLETE step (currently mocked with setTimeout).</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/components/LeadGenChat.tsx</path>
        <kind>interface</kind>
        <symbol>CollectedData</symbol>
        <lines>18-22</lines>
        <reason>Data structure for collected lead information: {name?: string, email?: string, projectDetails?: string}. This data needs to be sent to email API endpoint.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/components/LeadGenChat.tsx</path>
        <kind>function</kind>
        <symbol>processConversationStep</symbol>
        <lines>97-191</lines>
        <reason>Handles conversation flow logic. COMPLETE step (lines 174-177) is where email API call should be triggered after user confirms details.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/services/trpc.tsx</path>
        <kind>service</kind>
        <symbol>trpc</symbol>
        <lines>1-33</lines>
        <reason>tRPC client setup with createTRPCReact, httpBatchLink, and TRPCProvider. Use trpc.email.sendLead.mutate() to call backend email endpoint. API URL from VITE_API_URL env variable.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/types/trpc.ts</path>
        <kind>interface</kind>
        <symbol>SendLeadInput</symbol>
        <lines>22-26</lines>
        <reason>Type definition for email API input: {name: string, email: string, message: string}. Must match backend API contract.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/types/trpc.ts</path>
        <kind>interface</kind>
        <symbol>SendLeadOutput</symbol>
        <lines>28-31</lines>
        <reason>Type definition for email API output: {success: boolean, message?: string}. Use to handle success/error states.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/types/trpc.ts</path>
        <kind>type</kind>
        <symbol>AppRouter</symbol>
        <lines>41-68</lines>
        <reason>tRPC router type definition with email.sendLead procedure. Provides type safety for API calls.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/components/__tests__/LeadGenChat.test.tsx</path>
        <kind>test</kind>
        <symbol>LeadGenChat Component Tests</symbol>
        <lines>1-400</lines>
        <reason>Comprehensive test suite for LeadGenChat component. Includes tests for conversation flow, validation, loading states, and personality. Use as reference for testing email API integration.</reason>
      </file>
      <file>
        <path>portfolio-react-template/src/services/mockRAG.ts</path>
        <kind>service</kind>
        <symbol>mockRAGQuery</symbol>
        <lines>1-111</lines>
        <reason>Example of mock API implementation pattern used in Story 2.1. Can reference for creating mock email API if needed for parallel development.</reason>
      </file>
    </code>

    <dependencies>
      <node>
        <package name="@trpc/client" version="^11.7.1" />
        <package name="@trpc/react-query" version="^11.7.1" />
        <package name="@tanstack/react-query" version="^5.90.10" />
        <package name="react" version="^19.2.0" />
        <package name="zustand" version="^5.0.8" />
        <package name="@testing-library/react" version="^16.3.0" />
        <package name="@testing-library/jest-dom" version="^6.9.1" />
        <package name="jest" version="^30.2.0" />
        <package name="ts-jest" version="^29.4.5" />
      </node>
    </dependencies>
  </artifacts>

  <constraints>
    - Backend Dependency: Epic 4, Story 4.5 (Email API Endpoint) must be completed and deployed before this story can be fully tested. The backend must implement trpc.email.sendLead procedure.

    - Type Safety: All tRPC calls must use proper TypeScript types from AppRouter. The SendLeadInput must exactly match the backend contract.

    - Error Handling: Follow tRPC error handling conventions. Use try-catch blocks for async API calls. Handle network errors, timeouts, and API errors gracefully.

    - Personality Consistency: All user-facing messages (success, error, loading) must follow Ursa's personality guidelines: conversational tone, empathetic, helpful, use appropriate emoji (not overused).

    - State Management: Use React useState for component-level state (isLoading, error states). Do not create new Zustand stores for this story unless absolutely necessary.

    - Loading States: Display loading indicator during API call. Disable user input while loading. Clear loading state after success or error.

    - Data Mapping: CollectedData.projectDetails maps to SendLeadInput.message field (the "message" field contains project requirements/details).

    - Testing Standards: Add integration tests for email API interaction. Mock tRPC client in tests. Test success flow, error scenarios, loading states, and message personality.

    - No Direct Email Sending: Frontend must never handle email sending directly or access email service API keys. All email logic is backend-only via tRPC endpoint.

    - Environment Variables: Backend API URL configured via VITE_API_URL environment variable (default: http://localhost:3000/trpc).
  </constraints>

  <interfaces>
    <interface>
      <name>trpc.email.sendLead</name>
      <kind>tRPC mutation</kind>
      <signature>
        trpc.email.sendLead.mutate({
          name: string,
          email: string,
          message: string
        }): Promise&lt;SendLeadOutput&gt;
      </signature>
      <path>portfolio-react-template/src/services/trpc.tsx</path>
      <notes>Backend Epic 4 Story 4.5 implements this endpoint. Returns {success: boolean, message?: string}. Use in LeadGenChat COMPLETE step to send collected data.</notes>
    </interface>

    <interface>
      <name>CollectedData</name>
      <kind>TypeScript interface</kind>
      <signature>
        interface CollectedData {
          name?: string;
          email?: string;
          projectDetails?: string;
        }
      </signature>
      <path>portfolio-react-template/src/components/LeadGenChat.tsx:18-22</path>
      <notes>Current state in LeadGenChat component. Map to SendLeadInput: {name, email, message: projectDetails}.</notes>
    </interface>

    <interface>
      <name>SendLeadInput</name>
      <kind>TypeScript interface (API contract)</kind>
      <signature>
        interface SendLeadInput {
          name: string;
          email: string;
          message: string;
        }
      </signature>
      <path>portfolio-react-template/src/types/trpc.ts:22-26</path>
      <notes>Backend API input contract. All fields required (non-optional). Ensure CollectedData is fully populated before calling API.</notes>
    </interface>

    <interface>
      <name>SendLeadOutput</name>
      <kind>TypeScript interface (API response)</kind>
      <signature>
        interface SendLeadOutput {
          success: boolean;
          message?: string;
        }
      </signature>
      <path>portfolio-react-template/src/types/trpc.ts:28-31</path>
      <notes>Backend API response. Check success boolean for flow control. Optional message field may contain backend errors or confirmation text.</notes>
    </interface>

    <interface>
      <name>ConversationStep</name>
      <kind>TypeScript type</kind>
      <signature>
        type ConversationStep = 'GREETING' | 'NAME' | 'EMAIL' | 'PROJECT_DETAILS' | 'CONFIRMATION' | 'COMPLETE'
      </signature>
      <path>portfolio-react-template/src/components/LeadGenChat.tsx:10-16</path>
      <notes>Current conversation state. Email API call triggers in COMPLETE step. Modify processConversationStep logic to call API instead of mock timeout.</notes>
    </interface>
  </interfaces>

  <tests>
    <standards>
      Testing framework: Jest with React Testing Library (@testing-library/react, @testing-library/jest-dom). Tests use render(), screen, fireEvent, waitFor patterns. Component tests co-located in __tests__ directories. Integration tests should mock tRPC client using jest.mock(). Existing LeadGenChat.test.tsx has 18 test cases covering conversation flow, validation, loading states, personality - use as reference pattern.
    </standards>

    <locations>
      - portfolio-react-template/src/components/__tests__/*.test.tsx
      - portfolio-react-template/src/services/__mocks__/@trpc/react-query.ts (mock tRPC for testing)
    </locations>

    <ideas>
      <test ac="1,2">
        Should call trpc.email.sendLead.mutate() with correct data when conversation reaches COMPLETE step
        - Mock tRPC client mutation
        - Complete conversation flow (name → email → project details)
        - Verify mutate() called with {name: 'TestName', email: 'test@example.com', message: 'Test project details'}
      </test>

      <test ac="3,6">
        Should display Ursa-personality success message when email API returns success
        - Mock successful API response: {success: true}
        - Complete conversation flow
        - Verify success message appears: "Got it! I've sent your message to Vansh..." or similar
        - Verify message includes emoji and conversational tone
      </test>

      <test ac="4,6">
        Should display Ursa-personality error message when email API fails
        - Mock failed API response: {success: false, message: 'Network error'}
        - Complete conversation flow
        - Verify error message appears with fallback contact info
        - Verify empathetic tone: "Hmm, something went wrong..." pattern
      </test>

      <test ac="4">
        Should handle network timeout gracefully
        - Mock API to throw timeout error
        - Verify error message displays with fallback email address
        - Verify chat remains functional after error (user can retry)
      </test>

      <test ac="5">
        Should show loading indicator while email API call is pending
        - Mock API with delayed response
        - Verify "Typing..." indicator appears during API call
        - Verify loading clears after API response
      </test>

      <test ac="5">
        Should disable input while email is sending
        - Mock API with delayed response
        - Verify send button is disabled during API call
        - Verify input field is disabled or non-interactive
        - Verify controls re-enable after API completes
      </test>

      <test ac="2">
        Should map CollectedData to SendLeadInput correctly
        - Verify projectDetails maps to message field
        - Verify all required fields are non-empty strings
        - Test edge cases: long messages, special characters, unicode
      </test>

      <test ac="1-6">
        Integration test: Full conversation flow with successful email send
        - Step through NAME → EMAIL → PROJECT_DETAILS
        - Mock successful API response
        - Verify complete flow: data collection → API call → success message
        - Verify UI state transitions correctly throughout
      </test>
    </ideas>
  </tests>
</story-context>
